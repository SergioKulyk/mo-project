TEAM №5
=====================
### 1)Метод золотого перерізу
***
### 2)Метод хорд
***
### 3)Метод конфігурацій (Хука-Дживса)
***
### 4)Метод найшвидшого градієнтного спуску
***
### 5)Метод Макварда
***
### 6)Метод рою частинок


Метод золотого перерізу
-

#### Вхідні данні:<br> 
***a, b*** - початкові межі відрізка.<br>
**eps** - точність.<br>
**f** - функція<br>
#### Вихідні дані:<br>
 **х** - безумовний мінімум функції.<br>

 
 ### Як використовувати
```python
 Team5.golden_section(a, b, f, eps=10**(-4), t=0.38196)
```

1. Задаються початкові межі відрізка ***a, b*** і точність **eps**.
2. Розраховують початкові точки поділу ***x1 = b - (b-a)/phi, x2 = a - (b-a)/phi***, де ***phi*** — пропорція золотого перерізу і значення в них цільової функції: ***y1 = f(x1), y2 = f(x2).***
  + Якщо ***y1 >= y2*** (для пошуку максимуму змінити нерівність на ***y1 <= y2***), то ***a = x1***.
  + Інакше ***b = x2***.
3. 
+ Якщо ***|b - a| < eps***, то ***x = (a+b)/2*** і зупинитися.
+ Інакше повернутися до кроку 2.
4. Вихідні дані **х**


Метод хорд
-

#### Вхідні данні:<br> 
***a, b*** - початкові межі відрізка.<br>
**eps** - точність.<br>
**f** - функція<br>
**df** - друга похідна функції<br>
#### Вихідні дані:<br>
 **х** - локальний мінімум функції.<br>
 
  ### Як використовувати
```python
 Team5.toxins(a, b, f, df, eps=10 ** (-4))
```
 

1. Задаються **f(x), f’’(x)**, початкові межі відрізка ***a, b*** і точність **eps**.
2. Якщо **f(a) ⋅ f’’(a) > 0**, то **c = a** в іншому впадку якщо **f(b)·f’’(b)>0**, то **c=b**.
3. Якщо **f(a) ⋅ f’’(a) < 0**, то в іншому впадку якщо **f(b)·f’’(b) < 0**, то **x = b**.
4. **Δx = f(x)·(x-c)/(f(x)-f(c)).**
5. **x = x - Δx.**
6. Якщо **|Δx| > eps**, то повернутись до кроку 4.
7. Вихідні дані **х**.

Значення x є рішенням с заданной точністью **eps** неленійного рівняння виду **f(x)=0.**
Якщо **f(x)=0**, то **x** — точне рішення.


Метод конфігурацій(Хука-Дживса)
-

#### Вхідні данні:<br> 
***x0*** - початкова точка.<br>
**eps** - точність.<br>
**f** - функція<br>
**delta=0.5**<br>
**alpha=2.** - константа<br>
**lamb=1.** - константа<br>
#### Вихідні дані:<br>
 **х1** - мінімум функції.<br>
 
  ### Як використовувати
```python
 Team5.huca_jivsa(x0, f, delta=0.5, alpha=2., lamb=1., eps=10e-4)
```

1. Задати початкову точку **x0**, число **eps** - для зупинки алгоритму, початкові значення приростів по координатним приростам **Δx1, Δx2,...,Δxn >= eps**, прискорюючий множник **λ ≻ 0, i = 1, k = 0**.
2. Провести досліджуючий пошукпо вибраному координатному напрямку: xi(k+1) = 
+ xki+Δki, f(xk1,...,xki+Δki,...,xkn)<f(xk1,...,xki,...,xkn)
+ xki−Δki, f(xk1,...,xki−Δki,...,xkn)<minf(xk1,...,xki,...,xkn),(xk1,...,xki−Δki,...,xkn)
+ xki.   
3. Перевірити умови:
+ Якщо **i<n**, то поставити **i=i+1** і перейти до кроку 2. (продовжити досліджуючий пошук по напрямкам, які залишилися).
+ Якщо **i=n**, перевірити успішність досліджуючого пошуку: - якщо **f(Xk+1)<f(Xk)**, перейти до кроку 4; - якщо **f(Xk+1)≥f(Xk)**, перейти до кроку 5.
4. Провести пошук за зразком:
***
**Xzr = Xk + 1 + λ⋅(Xk+1−Xk)** 
***
В точці **Xzr** провести досліджуючий пошук, в результаті якого отримується точка **Xdp**. Якщо **Xdp≠Xzr**, то точка **Xk+1=Xdp** стає точкою нового базису, а **Xk** - точкою старого базису. Перейти до кроку 5. Якщо **Xdp=Xzr**, то пошук за зрозком вважається неуспішним, точки **Xdp,Xzr** анулюються, точка **Xk+1** залишається точкою нового базису, а **Xk** - точкою старого базису. Перейти до кроку 2.
5. Перевірити умову завершення обрахунку:
+ Якщо всі **i < eps** то пошук закінчити **X∗=Xk**.
+ Для тих і, для яких **Δi > eps**, зменшити величину кроку іперейти до кроку 2.
6. Вихідні дані **х**.


Метод найшвидшого градієнтного спуску
-

#### Вхідні данні:<br> 
***a, b*** - початкові межі відрізка.<br>
**eps** - точність.<br>
**f** - функція<br>
#### Вихідні дані:<br>
 **х** - локальний мінімум функції.<br>
 
  ### Як використовувати
```python
 Team5.huca_jivsa(x, h, a, lam, f, eps=10e-4)
```
1. Задати початкове наближення **x0**, точність **eps.**
2. Розраховують **x(j+1)**.
3. Перевіряют умови зупинки:
+ Якщо **|x(j+1) - x(j)| > eps**, то **j = j + 1** та переходимо до кроку 2.
+ В іншому випадку **x(j) = x(j+1)** та зупинитись.
4. Вихідні дані: **х**.


Метод Макварда
-

#### Вхідні данні:<br> 
***x0*** - початкова точка.<br>
**eps** - точність.<br>
**f** - функція<br>
**u** - константа<br>
**max_iter** - максимальна кількість ітерацій<br>
#### Вихідні дані:<br>
 **х1** - мінімум функції.<br>
 
### Як використовувати
```python
 Team5.mcvard(x0, f, eps=10**(-20), u=10**2, max_iter=50)
```

1. Задати **x0** – початкове наближення до **x** ,**M** – максимальна кількість ітерацій, **eps** – параметр сходження.
2. Вирахувати **f(x(k))**.
3. Перевірити **|f(x(k))| < eps**.
4. Якщо **k >= M**, то перейти до 10.
5. Обрахувати крок **s(k)**, вирішивши систему **(H(k) + λ(k)⋅I)⋅s(k) = −f(x(k))**, де **H(k)** – матрица Гессе.
6.**x(k+1) = x(k) + s(k)**.
7. Перевірити: **f(x(k+1)) < f(x(k))**.
+ Якщо та, то перейти до кроку 8.
+ В іншому випадку перейти до кроку 9.
8. **λ(k+1) = 1/2λ(k), k = k + 1.** Перейти до кроку 2.
9. **λ(k) = 2λ(k).** Перейти до кроку 6.
10. Вихідні дані: **x(k), f(x(k)), |f(x(k))|, k.**


Метод рою частинок
-

#### Вхідні данні:<br> 
**s** - кількість часток у рою.<br>
**eps** - точність.<br>
**f** - функція<br>
**d** - розмырність гіперкуба<br>
**xmin** - нижня границя<br>
**xmax** - верхня границя<br>
**w** - константа<br>
**с1** - константа<br>
**с2** - константа<br>
**plot_animation** - параметр відрисовки
#### Вихідні дані:<br>
 **fp** - найкращий відомий стан рою.<br>
 
### Як використовувати
```python
 Team5.swarm_parties(s, d, f, swarm=50, xmin=-10, xmax=10, w=0.72, c1=1.19, c2=1.19, plot_animation=False)
```

1. Задаються **S** — кількість часток у рою, кожній з яких зіставлена координата **х(і)**,  швидкість **v(i)**, **p(i)** — найкраще з відомих положень частки ***i***, а **g** — найкращий відомий стан рою в цілому.
2. Згенерувати початкове положення частки за допомогою випадкового вектора **x(i) ~ U(blo, bup)**, де **blo** і **bup** — нижня й верхня границі простору рішень відповідно.
3. Присвоїти найкращому відомому положенню частки його початкове значення: **p(i) ← x(i)**.
+ Якщо **f(p(i)) < f(g)**, то оновити найкращий відомий стан рою: **g ← p(i)**.
4. Присвоїти значення швидкості частки: **v(i) ~ U(-(bup-blo), (bup-blo))**.
5. Поки не виконаний критерій зупинки, повторювати.
6. Згенерувати випадкові вектори **rp, rg ~ U(0,1)**.
7. Оновити швидкість частки: **v(i) ← ω⋅v(i) + φp⋅rp × (p(i)-x(i)) + φg⋅rg × (g-x(i))**, де операція × означає покомпонентне множення.
8. Оновити положення частки переносом xi на вектор швидкості: **x(i) ← x(i) + v(i).**
9. Якщо **f(x(i)) < f(p(i))**, то
+ Оновити найкраще відоме положення частки: **p(i) ← x(i).**
+ Якщо **f(pi) < f(g)**, то оновити найкращий відомий стан рою в цілому: **g ← pi**.
10. Вихідні дані: g.






```python
 Team5.toxins(a, b, f, df, eps):
  
```
